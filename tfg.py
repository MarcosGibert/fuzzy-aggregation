# -*- coding: utf-8 -*-
"""tfg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UkukaX5Sr3i1zY7A4EVFmSng3hsq8E-o
"""

from itertools import product

class DiscreteFuzzyNumber:
    def __init__(self, elements):
        #un dicionario donde las llaves son los elementos de L_n y los valores son los valores de pertenencia
        self.elements = elements

    def membership(self, x):
          #devuelve el valor de pertenencia
        return self.elements.get(x, 0.0)

    def is_equal(self, other):

      return self.elements == other.elements

    def alpha_cut(self, alpha):
        alpha_cut_elements = {}
        for x, mu in self.elements.items():
            if mu >= alpha:
                alpha_cut_elements[x] = mu
        return alpha_cut_elements


    def all_alpha_cuts(self):
      #devuelve todos los alpha cuts
        items = list(self.elements.items())
        unique_memberships = sorted({mu for _, mu in items}, reverse=True)
        alpha_cuts = {
            alpha: {x for x, mu in items if mu >= alpha}
            for alpha in unique_memberships
        }
        return alpha_cuts



    def extended_aggregation_alpha(self, alpha, aggregation, fuzzy_b):
        #dados un alfa, una función de agregación f(x,y) sobre la cadena finita L_n y dos números difusos A y B devuelve f(A^{\alpha}, B^{\alpha})

        alpha_cut_a = self.alpha_cut(alpha)
        alpha_cut_b = fuzzy_b.alpha_cut(alpha)
        result_set = {aggregation(x, y) for x in alpha_cut_a.keys() for y in alpha_cut_b.keys()}
        return result_set

    def extended_aggregation_cuts(self, aggregation, fuzzy_b):
        #devuelve el conjunto {f(A^{\alpha}, B^{\alpha}) | alpha en la unión de los valores de pertenencia de A y B}
        membership_values = sorted(set(self.elements.values()).union(fuzzy_b.elements.values()), reverse=True)
        result_dict = {}
        for alpha in membership_values:
            result_dict[alpha] = self.extended_aggregation_alpha(alpha, aggregation, fuzzy_b)
        return result_dict

    def extended_aggregation(self, aggregation, fuzzy_b):
         #A partir de una función de agregación devuelve la función de agregación extendida de A y B
        extended_cuts = self.extended_aggregation_cuts(aggregation, fuzzy_b)
        result_elements = {}
        assigned_elements = set()

        for alpha, values in sorted(extended_cuts.items(), reverse=True):
            if not values:
                continue
            min_value = min(values)
            max_value = max(values)
            for x in range(min_value, max_value + 1):
                if x not in assigned_elements:
                    result_elements[x] = alpha
                    assigned_elements.add(x)

        return DiscreteFuzzyNumber(result_elements)


    def to_interval_list(self, other=None):
        if other:
            combined_alphas = sorted(set(self.elements.values()).union(other.elements.values()), reverse=True)
        else:
            combined_alphas = sorted(set(self.elements.values()), reverse=True)

        interval_list = []
        for alpha in combined_alphas:
            indices = [x for x, mu in self.elements.items() if mu >= alpha]
            if indices:
                interval_list.append([min(indices), max(indices)])
        return interval_list
    @staticmethod
    def lex1_order(interval1, interval2):
        a, b = interval1
        c, d = interval2
        return a < c or (a == c and b <= d)

    @staticmethod
    def lex2_order(interval1, interval2):
        a, b = interval1
        c, d = interval2
        return b < d or (b == d and a <= c)

    @staticmethod
    def xy_order(interval1, interval2):
        a, b = interval1
        c, d = interval2
        return (a + b < c + d) or ((a + b == c + d) and (b - a <= d - c))
    @staticmethod
    def inc_order(interval1, interval2):
        a, b = interval1
        c, d = interval2
        return a < c or (a == c and d <= b)





    @staticmethod
    def compare(fuzzy1, fuzzy2, order_type):
        # Compara dos números borrosos según un orden especificado
        self_intervals = fuzzy1.to_interval_list(fuzzy2)
        other_intervals = fuzzy2.to_interval_list(fuzzy1)

        for self_interval, other_interval in zip(self_intervals, other_intervals):
            if order_type == 'lex1':
                if self_interval != other_interval:
                    return 1 if DiscreteFuzzyNumber.lex1_order(self_interval, other_interval) else 0
            elif order_type == 'lex2':
                if self_interval != other_interval:
                    return 1 if DiscreteFuzzyNumber.lex2_order(self_interval, other_interval) else 0
            elif order_type == 'xy':
                if self_interval != other_interval:
                    return 1 if DiscreteFuzzyNumber.xy_order(self_interval, other_interval) else 0
            elif order_type == 'inc':
                if self_interval != other_interval:
                    return 1 if DiscreteFuzzyNumber.inc_order(self_interval, other_interval) else 0


        return 1

    @staticmethod
    def increasing_generation(y, length_dfn):
      vectors = []
      n = len(y)
      for i in range(n):
        aux = [y[0]]
        if length_dfn == 1:
            vectors.append(aux)
        else:
            aux2 = DiscreteFuzzyNumber.increasing_generation(y, length_dfn - 1)
            for row in aux2:
                vectors.append([y[0]] + row)
        y = y[1:]
      return vectors
    @staticmethod
    def decreasing_generation(y, length_dfn):
        vectors = DiscreteFuzzyNumber.increasing_generation(y, length_dfn)
        if length_dfn != 1:
            vectors = [list(reversed(row)) for row in vectors]
        return vectors



    @staticmethod
    def merge(left, right, order_type):
        result = []
        i = j = 0

    # Combina los elementos en orden basado en compare(x, y)
        while i < len(left) and j < len(right):
          if DiscreteFuzzyNumber.compare(left[i], right[j],order_type) == 1:  # Si left[i] <= right[j]
            result.append(left[i])
            i += 1
          else:  # Si left[i] > right[j]
            result.append(right[j])
            j += 1

    # Agrega los elementos restantes
        result.extend(left[i:])
        result.extend(right[j:])
        return result







    @staticmethod
    def merge_sort(fuzzy_objects, order_type):

    # ordena los números borrosos según el orden especificado
      if len(fuzzy_objects) <= 1:
        return fuzzy_objects

    # Divide el array en dos mitades
      mid = len(fuzzy_objects) // 2
      left_half = DiscreteFuzzyNumber.merge_sort(fuzzy_objects[:mid], order_type)
      right_half = DiscreteFuzzyNumber.merge_sort(fuzzy_objects[mid:], order_type)

    # Combina las mitades ordenadas usando la función de comparación
      return DiscreteFuzzyNumber.merge(left_half, right_half, order_type)
    @staticmethod
    def all_dfns(n, m, order_type='lex1',y=None ):
      if y is None:
        y = [i / (m - 1) for i in range(m)]


      generated_dfns = []
      if n >= 2:
        for i in range(2, n+1):
            left_piece = DiscreteFuzzyNumber.increasing_generation(y, i - 1)
            for j in range(i, n+1):
                right_piece = DiscreteFuzzyNumber.decreasing_generation(y, n+1 - j)
                for left in left_piece:
                    for right in right_piece:
                        aux = left + [1] * (j - i + 1) + right
                        generated_dfns.append(aux)
      for i in range(1, n):
        for row in DiscreteFuzzyNumber.decreasing_generation(y, n+1 - i):
            generated_dfns.append([1] * i + row)
      for j in range(1, n+1):
        for row in DiscreteFuzzyNumber.increasing_generation(y, j):
            generated_dfns.append(row + [1] * (n+1 - j))
      generated_dfns.append([1] * (n+1))

    # Eliminar duplicados
      unique_dfns = list(map(list, set(map(tuple, generated_dfns))))

      # Convertir cada sublista en un objeto DiscreteFuzzyNumber (usando índices como llaves)
      fuzzy_objects = [DiscreteFuzzyNumber({indice: valor for indice, valor in enumerate(sublista)})
                     for sublista in unique_dfns]

    # Ordenar la lista usando merge_sort según el orden deseado
      sorted_fuzzy_objects = DiscreteFuzzyNumber.merge_sort(fuzzy_objects, order_type)
      return sorted_fuzzy_objects


    def pos(self,n, m, order_type='lex1',y=None):

    # Ordena todos los posible números borrosos en A^{L_nxY_m}
      sorted_fuzzy_numbers = DiscreteFuzzyNumber.all_dfns(n, m, order_type,y)

    # Encuentra la posición del número borroso dado en la lista
      for idx, fuzzy in enumerate(sorted_fuzzy_numbers):
        if fuzzy.is_equal(self):
            return idx
      return -1
    @staticmethod
    def pos_inverse(z, n, m, order_type='lex1',y=None):
      sorted_fuzzy_numbers = DiscreteFuzzyNumber.all_dfns(n, m, order_type,y)
      return sorted_fuzzy_numbers[z]

    def aggregation(self, other,f,n,m,order_type='lex1',y=None):
       sorted_fuzzy_numbers = DiscreteFuzzyNumber.all_dfns(n, m, order_type, y)

    # Buscamos la posición de self en la lista ordenada
       pos_self = next((idx for idx, fuzzy in enumerate(sorted_fuzzy_numbers) if fuzzy.is_equal(self)), -1)
    # Buscamos la posición de other en la lista ordenada
       pos_other = next((idx for idx, fuzzy in enumerate(sorted_fuzzy_numbers) if fuzzy.is_equal(other)), -1)

    # Aplicamos la función de agregación f a las posiciones obtenidas
       aggregated_pos = f(pos_self, pos_other)

    # Devolvemos el número difuso correspondiente a la posición resultante
       return sorted_fuzzy_numbers[aggregated_pos]



    def __repr__(self):
        ordered_elements = dict(sorted(self.elements.items()))
        return f"{ordered_elements}"

#Probamos el ejemplo del artículo "Aggregation of subjective evaluations based on
#discrete fuzzy numbers" de Riera y Torrens.

fuzzy1 = DiscreteFuzzyNumber({2: 0.6, 3: 1, 4:0.8, 5:0.7})
fuzzy2 = DiscreteFuzzyNumber({3: 0.3, 4: 0.6, 5:1, 6:0.7})
fuzzy3= DiscreteFuzzyNumber({2: 0.7, 3: 0.8, 4: 1, 5:0.5})

def uninorm(x, y):
      if x + y <= 8:
        return min(x, y)
      else:
        return max(x, y)

UAB_final = fuzzy1.extended_aggregation(uninorm, fuzzy2)
UABC_1=UAB_final.extended_aggregation(uninorm,fuzzy3)


print("Fuzzy 1:", fuzzy1)
print("Fuzzy 2:", fuzzy2)
print("Fuzzy 3:", fuzzy3)


print("Resultado:", UABC_1)

fuzzy1 = DiscreteFuzzyNumber({6: 0.8, 7: 0.9, 8:1})
fuzzy2 = DiscreteFuzzyNumber({5: 0.6, 6: 0.7, 7:1, 8:0.7})
fuzzy3= DiscreteFuzzyNumber({4: 0.5, 5: 0.7, 6: 1, 7:0.7, 8:0.4})


UAB_final = fuzzy1.extended_aggregation(uninorm, fuzzy2)
UABC_2=UAB_final.extended_aggregation(uninorm,fuzzy3)


print("Fuzzy 1:", fuzzy1)
print("Fuzzy 2:", fuzzy2)
print("Fuzzy 3:", fuzzy3)




print("Resultado:",UABC_2)

fuzzy1 = DiscreteFuzzyNumber({0: 0.1, 1: 0.6, 2:1, 3:0.4})
fuzzy2 = DiscreteFuzzyNumber({3: 0.5, 4: 0.7, 5:1,})
fuzzy3= DiscreteFuzzyNumber({2: 0.6, 3: 0.7, 4: 1, 5:0.8})


UAB_final = fuzzy1.extended_aggregation(uninorm, fuzzy2)
UABC_3=UAB_final.extended_aggregation(uninorm,fuzzy3)


print("Fuzzy 1:", fuzzy1)
print("Fuzzy 2:", fuzzy2)
print("Fuzzy 3:", fuzzy3)
print("Resultado:",UABC_3)

def uninorm(x, y):
      if 4 <= x <= 8 and 4 <= y <= 8 :
        return max(x, y)
      else:
        return min(x, y)


UAB_final = UABC_1.extended_aggregation(uninorm, UABC_2)
UABC=UAB_final.extended_aggregation(uninorm,UABC_3)


print("Fuzzy 1:", fuzzy1)
print("Fuzzy 2:", fuzzy2)
print("Fuzzy 3:", fuzzy3)
print(UABC)

# Ejemplo 1: Generar y ordenar dfns con n=4, m=3
sorted_dfns = DiscreteFuzzyNumber.all_dfns(n=4, m=3, order_type='lex1')
print("Lista ordenada de DFNs (n=4, m=3):")
for idx, dfn in enumerate(sorted_dfns):
    print(f"Posición {idx}: {dfn}")

# Ejemplo 2: Uso de pos y pos_inverse
    # Tomamos un elemento de la lista ordenada.
dfn_example = DiscreteFuzzyNumber({0: 0.0, 1: 1, 2: 1.0, 3: 1.0, 4: 0.0})
pos_example = dfn_example.pos(n=4, m=3, order_type='lex1')
print("\nPosición del DFN:", pos_example)
 # Recuperamos el DFN a partir de esa posición
recovered_dfn = DiscreteFuzzyNumber.pos_inverse(pos_example, n=4, m=3, order_type='lex1')
print("DFN recuperado con pos_inverse:", recovered_dfn)

# Ejemplo 3: Uso de aggregation
    # Agregamos los dos primeros DFNs usando la función media.
def media(x,y):
  return int((x+y)//2)

dfn1 = DiscreteFuzzyNumber({0: 0.0, 1: 1, 2: 1.0, 3: 0.5, 4: 0.0})
dfn2 = DiscreteFuzzyNumber({0: 0.5, 1: 1, 2: 0.5, 3: 0.0, 4: 0.0})
aggregated = dfn1.aggregation(dfn2, media, n=4, m=3, order_type='lex1')
print("\nResultado de la agregación:", aggregated)
